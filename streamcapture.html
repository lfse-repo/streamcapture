<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>streamcapture API documentation</title>
<meta name="description" content="streamcapture: capture the outputs of Python streams, such as sys.stdout and sys.stderr …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>streamcapture</code></h1>
</header>
<section id="section-intro">
<h2 id="streamcapture-capture-the-outputs-of-python-streams-such-as-sysstdout-and-sysstderr">streamcapture: capture the outputs of Python streams, such as sys.stdout and sys.stderr</h2>
<h3 id="author-sebastien-loisel">Author: Sébastien Loisel</h3>
<h1 id="installation">Installation</h1>
<p><code>pip install <a title="streamcapture" href="#streamcapture">streamcapture</a></code></p>
<h1 id="example-usage">Example usage</h1>
<pre><code class="language-python">import streamcapture, sys, os
print(&quot;This does not get saved to the log file&quot;)
with streamcapture.StreamCapture(sys.stdout,open('logfile.txt','wb')):
        os.write(sys.stdout.fileno(),b&quot;Hello, captured world!\n&quot;)
        os.system('echo Hello from the shell')
        print(&quot;More capturing&quot;)
print(&quot;This also does not get saved to the log file&quot;)
</code></pre>
<p>After execution, this will create a file <code>logfile.txt</code> in the current directory, containing
the relevant captured outputs.</p>
<h1 id="documentation">Documentation</h1>
<p>Class <code>StreamCapture(stream, writer, echo=True, monkeypatch=None)</code> is able to capture,
at the operating system level, the data being written to the given <code>stream</code>.
A typical use is to capture all outputs to <code>sys.stdout</code> and <code>sys.stderr</code>
and log them to a file. This will even capture the outputs of spawned shell commands.</p>
<p><code><a title="streamcapture.StreamCapture" href="#streamcapture.StreamCapture">StreamCapture</a></code> works by essentially using <code>os.dup2</code> to send <code>stream.fileno()</code> to a <code>os.pipe()</code>.
A separate thread is used to listen to that <code>os.pipe</code> and send the outputs to the destination
<code>writer</code> stream. <code><a title="streamcapture.StreamCapture" href="#streamcapture.StreamCapture">StreamCapture</a></code> also uses <code>os.dup</code> to duplicate the original filedescriptor to be able
to restore it at the end. This duplicated filedescriptor is stored in <code>StreamCapture.dup_fd</code>, and
writing to this filedescriptor results in writing to the original file, before it was redirected.
For example, when redirecting <code>sys.stdout</code>, one can still write to the terminal by writing directly
to <code>StreamCapture.dup_fd</code> with <code>os.write()</code>.</p>
<p>On Windows, <code>sys.stdout</code> and <code>sys.stderr</code> do not take kindly to their <code>fileno()</code> being
redirected with <code>os.dup2</code>. <code><a title="streamcapture.StreamCapture" href="#streamcapture.StreamCapture">StreamCapture</a></code> features an optional workaround, enabled by the
<code>monkeypatching</code> optional parameter to the constructor. When enabled, the workaround
overwrites <code>stream.write(&hellip;)</code> by an implementation that sends everything to <code>os.write(self.fd,&hellip;)</code>.
This workaround is enabled when <code>monkeypatching=True</code> and disabled when <code>monkeypatching=False</code>.
The default is <code>monkeypatching=None</code>, in which case monkeypatching is enabled only when
<code>platform.system()=='Windows'</code>.</p>
<p>When writing to multiple streams and file descriptors, sometimes the order in which the writes
appear can be surprising. For example, when writing to stderr and stdout, these outputs do not
necessarily appear in the order in which they occurred during the program execution, because
of various levels of buffering that occur in Python, the C library or the operating system.</p>
<p>At the Python level, streams can be <code>flush()</code>ed to attempt to reduce the delay before a <code>write()</code>
has delivered its payload. Furthermore, <code>os.fsync()</code> can be used on some, but not all, file descriptors.
However, <code>os.fsync()</code> usually causes an exception if it is called on <code>sys.stdout.fileno()</code> or on a
<code>os.pipe()</code>. In principle, the operating system should promtly flush any buffers when a file descriptor
is <code>os.close()</code>d, but there is no guarantee. To complicate matters, although one usually prefers minimal
buffering for outputs that go to the console, Python tries very hard to force some sort of buffering on
text-mode files.</p>
<p>We have tried to prevent most forms of buffering at the Python level and at the operating system levels,
but when multiple file descriptors are used, or at the boundary when a <code><a title="streamcapture.StreamCapture" href="#streamcapture.StreamCapture">StreamCapture</a></code> starts or stops
capturing the underlying stream, some outputs that go to the console may appear in an unexpected order.</p>
<p>More sophisticated behaviors can be handled by implementing a custom stream-like object.
The <code>writer</code> object should implement functions <code>writer.write(data)</code>, where <code>data</code> is a byte string,
and <code>writer.close()</code>.</p>
<p>The <code>echo</code> flag can be set at construction time <code>StreamCapture(...,echo=True)</code> and defaults to <code>True</code>.
In this mode, all captured outputs are sent both to the <code>writer</code> and also to <code>StreamCapture.dup_fd</code>.
This allows one to send, e.g. <code>stdout</code> to a log file while simultaneously printing it to the console,
similar to the <code>tee</code> console command in Unix. The <code>echo</code> flag can be set to <code>False</code> to disable this.</p>
<p>One can call <code><a title="streamcapture.StreamCapture.close" href="#streamcapture.StreamCapture.close">StreamCapture.close()</a></code> to cleanly unwind the captured streams. This is automatically
done if <code><a title="streamcapture.StreamCapture" href="#streamcapture.StreamCapture">StreamCapture</a></code> is used in a <code>with</code> block.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">r&#34;&#34;&#34;
## streamcapture: capture the outputs of Python streams, such as sys.stdout and sys.stderr

### Author: Sébastien Loisel

# Installation

`pip install streamcapture`

# Example usage

```python
import streamcapture, sys, os
print(&#34;This does not get saved to the log file&#34;)
with streamcapture.StreamCapture(sys.stdout,open(&#39;logfile.txt&#39;,&#39;wb&#39;)):
        os.write(sys.stdout.fileno(),b&#34;Hello, captured world!\n&#34;)
        os.system(&#39;echo Hello from the shell&#39;)
        print(&#34;More capturing&#34;)
print(&#34;This also does not get saved to the log file&#34;)
```

After execution, this will create a file `logfile.txt` in the current directory, containing
the relevant captured outputs.

# Documentation

Class `StreamCapture(stream, writer, echo=True, monkeypatch=None)` is able to capture,
at the operating system level, the data being written to the given `stream`.
A typical use is to capture all outputs to `sys.stdout` and `sys.stderr`
and log them to a file. This will even capture the outputs of spawned shell commands.

`StreamCapture` works by essentially using `os.dup2` to send `stream.fileno()` to a `os.pipe()`.
A separate thread is used to listen to that `os.pipe` and send the outputs to the destination
`writer` stream. `StreamCapture` also uses `os.dup` to duplicate the original filedescriptor to be able
to restore it at the end. This duplicated filedescriptor is stored in `StreamCapture.dup_fd`, and
writing to this filedescriptor results in writing to the original file, before it was redirected.
For example, when redirecting `sys.stdout`, one can still write to the terminal by writing directly
to `StreamCapture.dup_fd` with `os.write()`.

On Windows, `sys.stdout` and `sys.stderr` do not take kindly to their `fileno()` being
redirected with `os.dup2`. `StreamCapture` features an optional workaround, enabled by the
`monkeypatching` optional parameter to the constructor. When enabled, the workaround
overwrites `stream.write(...)` by an implementation that sends everything to `os.write(self.fd,...)`.
This workaround is enabled when `monkeypatching=True` and disabled when `monkeypatching=False`.
The default is `monkeypatching=None`, in which case monkeypatching is enabled only when 
`platform.system()==&#39;Windows&#39;`.

When writing to multiple streams and file descriptors, sometimes the order in which the writes
appear can be surprising. For example, when writing to stderr and stdout, these outputs do not
necessarily appear in the order in which they occurred during the program execution, because
of various levels of buffering that occur in Python, the C library or the operating system.

At the Python level, streams can be `flush()`ed to attempt to reduce the delay before a `write()`
has delivered its payload. Furthermore, `os.fsync()` can be used on some, but not all, file descriptors.
However, `os.fsync()` usually causes an exception if it is called on `sys.stdout.fileno()` or on a
`os.pipe()`. In principle, the operating system should promtly flush any buffers when a file descriptor
is `os.close()`d, but there is no guarantee. To complicate matters, although one usually prefers minimal
buffering for outputs that go to the console, Python tries very hard to force some sort of buffering on
text-mode files.

We have tried to prevent most forms of buffering at the Python level and at the operating system levels,
but when multiple file descriptors are used, or at the boundary when a `StreamCapture` starts or stops
capturing the underlying stream, some outputs that go to the console may appear in an unexpected order.

More sophisticated behaviors can be handled by implementing a custom stream-like object.
The `writer` object should implement functions `writer.write(data)`, where `data` is a byte string,
and `writer.close()`.

The `echo` flag can be set at construction time `StreamCapture(...,echo=True)` and defaults to `True`.
In this mode, all captured outputs are sent both to the `writer` and also to `StreamCapture.dup_fd`.
This allows one to send, e.g. `stdout` to a log file while simultaneously printing it to the console,
similar to the `tee` console command in Unix. The `echo` flag can be set to `False` to disable this.

One can call `StreamCapture.close()` to cleanly unwind the captured streams. This is automatically
done if `StreamCapture` is used in a `with` block.
&#34;&#34;&#34;

import os, sys, threading, platform

class StreamCapture:
        def __init__(self,stream,writer,echo=True,monkeypatch=None):
                &#34;&#34;&#34;
                The `StreamCapture` constructor. Parameters are:

                * `stream`: The stream to capture (e.g. `sys.stdout`). This stream should be connected to an
                            underlying `fileno()`.
                * `writer`: The stream to write to (e.g. `writer=open(&#39;logfile.txt&#39;,&#39;wb&#39;))`). If applicable, the
                            `writer` stream should be opened in binary mode. This object need not be an actual
                            Python stream; any object that implements functions `writer.write(data)` and 
                            `writer.close()` is suitable here. The only caveat is that `StreamCapture` will
                            call into `writer` from a separate thread, so if `writer.write()` or `writer.close()`
                            have significant side-effects, then one should make use of appropriate locking
                            primitives. This is not necessary for plain-old files obtained from `open(...)`, but
                            if a writer accumulates the outputs in an in-memory list, then one should use
                            appropriate thread-safe locking to interact with this list from the main thread.
                * `echo=True`: If `True`, send data to `StreamCapture.dup_fd` in addition to `StreamCapture.writer()`.
                * `monkeypatch`: If `True`, replaces `stream.write(data)` with `os.write(fd,data)` (more or less).
                               This is necessary on Windows for `stdout` and `stderr`.
                               The default is to enable monkeypatching only
                               when Windows is detected via `platform.system()==&#39;Windows&#39;`.
                &#34;&#34;&#34;
                self.active = True
                self.writer = writer
                self.stream = stream
                self.fd = stream.fileno()
                self.echo = echo
                (r,w) = os.pipe()
                self.pipe_read_fd = r
                self.pipe_write_fd = w
                self.dup_fd = os.dup(self.fd)
                os.dup2(w,self.fd)
                self.monkeypatch = monkeypatch if monkeypatch is not None else (True if platform.system()==&#39;Windows&#39; else False)
                if self.monkeypatch:
                        self.oldwrite = stream.write
                        stream.write = lambda z: os.write(self.fd,z.encode() if type(z)==str else z)
                t = threading.Thread(target=self.printer)
                self.thread = t
                t.start()
        def printer(self):
                &#34;&#34;&#34;This is the thread that listens to the pipe output and passes it to the writer stream.&#34;&#34;&#34;
                pipe_read_fd = self.pipe_read_fd
                while True:
                        data = os.read(pipe_read_fd,100000)
                        if(len(data)==0):
                                self.writer.close()
                                os.close(self.dup_fd)
                                os.close(self.pipe_read_fd)
                                return
                        self.writer.write(data)
                        if self.echo:
                                os.write(self.dup_fd,data)
        def close(self):
                &#34;&#34;&#34;When you want to &#34;uncapture&#34; a stream, use this method.&#34;&#34;&#34;
                if not self.active:
                        return
                self.active = False
                self.stream.flush()
                if self.monkeypatch:
                        self.stream.write = self.oldwrite
                os.dup2(self.dup_fd,self.fd)
                os.close(self.pipe_write_fd)
        def __enter__(self):
                return self
        def __exit__(self,a,b,c):
                self.close()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="streamcapture.StreamCapture"><code class="flex name class">
<span>class <span class="ident">StreamCapture</span></span>
<span>(</span><span>stream, writer, echo=True, monkeypatch=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The <code><a title="streamcapture.StreamCapture" href="#streamcapture.StreamCapture">StreamCapture</a></code> constructor. Parameters are:</p>
<ul>
<li><code>stream</code>: The stream to capture (e.g. <code>sys.stdout</code>). This stream should be connected to an
underlying <code>fileno()</code>.</li>
<li><code>writer</code>: The stream to write to (e.g. <code>writer=open('logfile.txt','wb'))</code>). If applicable, the
<code>writer</code> stream should be opened in binary mode. This object need not be an actual
Python stream; any object that implements functions <code>writer.write(data)</code> and
<code>writer.close()</code> is suitable here. The only caveat is that <code><a title="streamcapture.StreamCapture" href="#streamcapture.StreamCapture">StreamCapture</a></code> will
call into <code>writer</code> from a separate thread, so if <code>writer.write()</code> or <code>writer.close()</code>
have significant side-effects, then one should make use of appropriate locking
primitives. This is not necessary for plain-old files obtained from <code>open(&hellip;)</code>, but
if a writer accumulates the outputs in an in-memory list, then one should use
appropriate thread-safe locking to interact with this list from the main thread.</li>
<li><code>echo=True</code>: If <code>True</code>, send data to <code>StreamCapture.dup_fd</code> in addition to <code>StreamCapture.writer()</code>.</li>
<li><code>monkeypatch</code>: If <code>True</code>, replaces <code>stream.write(data)</code> with <code>os.write(fd,data)</code> (more or less).
This is necessary on Windows for <code>stdout</code> and <code>stderr</code>.
The default is to enable monkeypatching only
when Windows is detected via <code>platform.system()=='Windows'</code>.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StreamCapture:
        def __init__(self,stream,writer,echo=True,monkeypatch=None):
                &#34;&#34;&#34;
                The `StreamCapture` constructor. Parameters are:

                * `stream`: The stream to capture (e.g. `sys.stdout`). This stream should be connected to an
                            underlying `fileno()`.
                * `writer`: The stream to write to (e.g. `writer=open(&#39;logfile.txt&#39;,&#39;wb&#39;))`). If applicable, the
                            `writer` stream should be opened in binary mode. This object need not be an actual
                            Python stream; any object that implements functions `writer.write(data)` and 
                            `writer.close()` is suitable here. The only caveat is that `StreamCapture` will
                            call into `writer` from a separate thread, so if `writer.write()` or `writer.close()`
                            have significant side-effects, then one should make use of appropriate locking
                            primitives. This is not necessary for plain-old files obtained from `open(...)`, but
                            if a writer accumulates the outputs in an in-memory list, then one should use
                            appropriate thread-safe locking to interact with this list from the main thread.
                * `echo=True`: If `True`, send data to `StreamCapture.dup_fd` in addition to `StreamCapture.writer()`.
                * `monkeypatch`: If `True`, replaces `stream.write(data)` with `os.write(fd,data)` (more or less).
                               This is necessary on Windows for `stdout` and `stderr`.
                               The default is to enable monkeypatching only
                               when Windows is detected via `platform.system()==&#39;Windows&#39;`.
                &#34;&#34;&#34;
                self.active = True
                self.writer = writer
                self.stream = stream
                self.fd = stream.fileno()
                self.echo = echo
                (r,w) = os.pipe()
                self.pipe_read_fd = r
                self.pipe_write_fd = w
                self.dup_fd = os.dup(self.fd)
                os.dup2(w,self.fd)
                self.monkeypatch = monkeypatch if monkeypatch is not None else (True if platform.system()==&#39;Windows&#39; else False)
                if self.monkeypatch:
                        self.oldwrite = stream.write
                        stream.write = lambda z: os.write(self.fd,z.encode() if type(z)==str else z)
                t = threading.Thread(target=self.printer)
                self.thread = t
                t.start()
        def printer(self):
                &#34;&#34;&#34;This is the thread that listens to the pipe output and passes it to the writer stream.&#34;&#34;&#34;
                pipe_read_fd = self.pipe_read_fd
                while True:
                        data = os.read(pipe_read_fd,100000)
                        if(len(data)==0):
                                self.writer.close()
                                os.close(self.dup_fd)
                                os.close(self.pipe_read_fd)
                                return
                        self.writer.write(data)
                        if self.echo:
                                os.write(self.dup_fd,data)
        def close(self):
                &#34;&#34;&#34;When you want to &#34;uncapture&#34; a stream, use this method.&#34;&#34;&#34;
                if not self.active:
                        return
                self.active = False
                self.stream.flush()
                if self.monkeypatch:
                        self.stream.write = self.oldwrite
                os.dup2(self.dup_fd,self.fd)
                os.close(self.pipe_write_fd)
        def __enter__(self):
                return self
        def __exit__(self,a,b,c):
                self.close()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="streamcapture.StreamCapture.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>When you want to "uncapture" a stream, use this method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
        &#34;&#34;&#34;When you want to &#34;uncapture&#34; a stream, use this method.&#34;&#34;&#34;
        if not self.active:
                return
        self.active = False
        self.stream.flush()
        if self.monkeypatch:
                self.stream.write = self.oldwrite
        os.dup2(self.dup_fd,self.fd)
        os.close(self.pipe_write_fd)</code></pre>
</details>
</dd>
<dt id="streamcapture.StreamCapture.printer"><code class="name flex">
<span>def <span class="ident">printer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This is the thread that listens to the pipe output and passes it to the writer stream.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def printer(self):
        &#34;&#34;&#34;This is the thread that listens to the pipe output and passes it to the writer stream.&#34;&#34;&#34;
        pipe_read_fd = self.pipe_read_fd
        while True:
                data = os.read(pipe_read_fd,100000)
                if(len(data)==0):
                        self.writer.close()
                        os.close(self.dup_fd)
                        os.close(self.pipe_read_fd)
                        return
                self.writer.write(data)
                if self.echo:
                        os.write(self.dup_fd,data)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#streamcapture-capture-the-outputs-of-python-streams-such-as-sysstdout-and-sysstderr">streamcapture: capture the outputs of Python streams, such as sys.stdout and sys.stderr</a><ul>
<li><a href="#author-sebastien-loisel">Author: Sébastien Loisel</a></li>
</ul>
</li>
<li><a href="#installation">Installation</a></li>
<li><a href="#example-usage">Example usage</a></li>
<li><a href="#documentation">Documentation</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="streamcapture.StreamCapture" href="#streamcapture.StreamCapture">StreamCapture</a></code></h4>
<ul class="">
<li><code><a title="streamcapture.StreamCapture.close" href="#streamcapture.StreamCapture.close">close</a></code></li>
<li><code><a title="streamcapture.StreamCapture.printer" href="#streamcapture.StreamCapture.printer">printer</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>